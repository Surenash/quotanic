"""
G-Code Generator Module
Generates CNC G-code from FBM operations
"""

from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import math


class GCodeDialect(Enum):
    """G-code dialects/controllers"""
    FANUC = "Fanuc"
    HAAS = "Haas"
    SIEMENS = "Siemens"
    HEIDENHAIN = "Heidenhain"
    MAZAK = "Mazak"
    GENERIC = "Generic ISO"


class CoolantMode(Enum):
    """Coolant modes"""
    OFF = "M9"
    FLOOD = "M8"
    MIST = "M7"
    THROUGH_TOOL = "M88"


@dataclass
class GCodeSettings:
    """G-code generation settings"""
    dialect: GCodeDialect = GCodeDialect.FANUC
    units: str = "metric"  # metric or imperial
    absolute_coords: bool = True  # G90 vs G91
    safe_z: float = 50.0  # mm, safe retract height
    rapid_z: float = 5.0  # mm, rapid height above part
    work_offset: str = "G54"  # Work coordinate system
    spindle_direction: str = "M3"  # M3=CW, M4=CCW
    feed_mode: str = "G94"  # G94=feed per minute, G95=feed per rev
    canned_cycles: bool = True  # Use G81, G83, etc.
    precision: int = 3  # Decimal places
    line_numbers: bool = False  # N-codes
    program_number: int = 1000


class GCodeGenerator:
    """Generate G-code from machining operations"""
    
    def __init__(self, settings: GCodeSettings = None):
        self.settings = settings or GCodeSettings()
        self.current_tool = None
        self.current_spindle_speed = 0
        self.current_feed_rate = 0
        self.line_number = 10
        
    def generate_program(self, operations: List, program_name: str = "FBM_PART") -> str:
        """Generate complete G-code program"""
        gcode = []
        
        # Program header
        gcode.extend(self._generate_header(program_name))
        
        # Initialize machine
        gcode.extend(self._generate_initialization())
        
        # Group operations by tool
        tool_groups = self._group_by_tool(operations)
        
        # Generate code for each tool
        for tool_id, ops in tool_groups.items():
            gcode.extend(self._generate_tool_change(tool_id, ops[0]))
            
            for op in ops:
                gcode.extend(self._generate_operation(op))
        
        # Program footer
        gcode.extend(self._generate_footer())
        
        return "\n".join(gcode)
    
    def _generate_header(self, program_name: str) -> List[str]:
        """Generate program header"""
        lines = []
        lines.append(f"%")
        lines.append(f"O{self.settings.program_number} ({program_name})")
        lines.append(f"(Generated by FBM System)")
        lines.append(f"(Date: {self._get_timestamp()})")
        lines.append(f"")
        return lines
    
    def _generate_initialization(self) -> List[str]:
        """Generate machine initialization"""
        lines = []
        lines.append(f"(INITIALIZATION)")
        
        if self.settings.units == "metric":
            lines.append("G21 (Metric)")
        else:
            lines.append("G20 (Inch)")
        
        if self.settings.absolute_coords:
            lines.append("G90 (Absolute positioning)")
        else:
            lines.append("G91 (Incremental positioning)")
        
        lines.append(self.settings.work_offset + " (Work offset)")
        lines.append(self.settings.feed_mode + " (Feed per minute)")
        lines.append("G40 (Cancel cutter comp)")
        lines.append("G49 (Cancel length comp)")
        lines.append("G80 (Cancel canned cycles)")
        lines.append("")
        
        return lines
    
    def _generate_tool_change(self, tool_id: str, operation) -> List[str]:
        """Generate tool change code"""
        lines = []
        lines.append(f"(TOOL: {tool_id})")
        
        # Extract tool number from ID (e.g., "EM-10mm-4F" -> T1)
        tool_num = self._extract_tool_number(tool_id)
        
        lines.append(f"M6 T{tool_num} ({tool_id})")
        lines.append(f"M3 S{int(operation.spindle_speed)} (Spindle CW)")
        lines.append("G43 H{} (Length offset)".format(tool_num))
        lines.append("")
        
        self.current_tool = tool_id
        self.current_spindle_speed = operation.spindle_speed
        
        return lines
    
    def _generate_operation(self, operation) -> List[str]:
        """Generate G-code for single operation"""
        lines = []
        
        op_type = operation.operation_name.lower()
        
        if "drill" in op_type:
            lines.extend(self._generate_drilling(operation))
        elif "pocket" in op_type:
            lines.extend(self._generate_pocketing(operation))
        elif "face" in op_type:
            lines.extend(self._generate_facing(operation))
        elif "thread" in op_type:
            lines.extend(self._generate_threading(operation))
        elif "contour" in op_type:
            lines.extend(self._generate_contouring(operation))
        else:
            lines.extend(self._generate_generic_milling(operation))
        
        return lines
    
    def _generate_drilling(self, operation) -> List[str]:
        """Generate drilling cycle"""
        lines = []
        lines.append(f"({operation.operation_name})")
        
        # Get hole parameters
        x_pos = getattr(operation.feature, 'center_x', 0) if hasattr(operation, 'feature') else 0
        y_pos = getattr(operation.feature, 'center_y', 0) if hasattr(operation, 'feature') else 0
        depth = getattr(operation, 'depth', 10)
        
        # Rapid to position
        lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        lines.append(f"G0 X{x_pos:.{self.settings.precision}f} Y{y_pos:.{self.settings.precision}f}")
        
        if self.settings.canned_cycles:
            # Use canned drilling cycle
            if depth > 30:
                # Peck drilling for deep holes
                peck = depth / 3
                lines.append(f"G83 Z-{depth:.{self.settings.precision}f} R{self.settings.rapid_z:.{self.settings.precision}f} Q{peck:.{self.settings.precision}f} F{operation.feed_rate:.0f}")
            else:
                # Standard drilling
                lines.append(f"G81 Z-{depth:.{self.settings.precision}f} R{self.settings.rapid_z:.{self.settings.precision}f} F{operation.feed_rate:.0f}")
            lines.append("G80 (Cancel cycle)")
        else:
            # Manual drilling
            lines.append(f"G0 Z{self.settings.rapid_z:.{self.settings.precision}f}")
            lines.append(f"G1 Z-{depth:.{self.settings.precision}f} F{operation.feed_rate:.0f}")
            lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        
        lines.append("")
        return lines
    
    def _generate_pocketing(self, operation) -> List[str]:
        """Generate pocketing toolpath"""
        lines = []
        lines.append(f"({operation.operation_name})")
        
        # Simplified spiral pocketing
        width = getattr(operation, 'width', 20)
        length = getattr(operation, 'length', 30)
        depth = getattr(operation, 'depth', 10)
        stepover = getattr(operation, 'tool_diameter', 10) * 0.4
        stepdown = getattr(operation, 'tool_diameter', 10) * 0.5
        
        center_x = width / 2
        center_y = length / 2
        
        # Multiple depth passes
        num_passes = int(math.ceil(depth / stepdown))
        
        for pass_num in range(num_passes):
            current_depth = min((pass_num + 1) * stepdown, depth)
            
            lines.append(f"(Pass {pass_num + 1}/{num_passes}, depth: {current_depth:.{self.settings.precision}f}mm)")
            
            # Spiral pattern
            current_radius = stepover
            while current_radius < min(width, length) / 2:
                # Enter at center
                if pass_num == 0 and current_radius == stepover:
                    lines.append(f"G0 X{center_x:.{self.settings.precision}f} Y{center_y:.{self.settings.precision}f}")
                    lines.append(f"G0 Z{self.settings.rapid_z:.{self.settings.precision}f}")
                    lines.append(f"G1 Z-{current_depth:.{self.settings.precision}f} F{operation.feed_rate * 0.5:.0f}")
                
                # Circular motion
                lines.append(f"G3 X{center_x + current_radius:.{self.settings.precision}f} Y{center_y:.{self.settings.precision}f} I{current_radius:.{self.settings.precision}f} J0 F{operation.feed_rate:.0f}")
                
                current_radius += stepover
        
        # Retract
        lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        lines.append("")
        
        return lines
    
    def _generate_facing(self, operation) -> List[str]:
        """Generate face milling"""
        lines = []
        lines.append(f"({operation.operation_name})")
        
        width = getattr(operation, 'width', 100)
        length = getattr(operation, 'length', 100)
        depth = getattr(operation, 'depth', 2)
        tool_dia = getattr(operation, 'tool_diameter', 50)
        stepover = tool_dia * 0.7
        
        lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        
        # Zigzag pattern
        y_pos = 0
        direction = 1
        
        while y_pos <= length:
            lines.append(f"G0 Y{y_pos:.{self.settings.precision}f}")
            
            if direction == 1:
                lines.append(f"G0 X0")
                lines.append(f"G1 Z-{depth:.{self.settings.precision}f} F{operation.feed_rate * 0.5:.0f}")
                lines.append(f"G1 X{width:.{self.settings.precision}f} F{operation.feed_rate:.0f}")
            else:
                lines.append(f"G0 X{width:.{self.settings.precision}f}")
                lines.append(f"G1 Z-{depth:.{self.settings.precision}f} F{operation.feed_rate * 0.5:.0f}")
                lines.append(f"G1 X0 F{operation.feed_rate:.0f}")
            
            lines.append(f"G0 Z{self.settings.rapid_z:.{self.settings.precision}f}")
            
            y_pos += stepover
            direction *= -1
        
        lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        lines.append("")
        
        return lines
    
    def _generate_threading(self, operation) -> List[str]:
        """Generate thread milling"""
        lines = []
        lines.append(f"({operation.operation_name} - Thread Milling)")
        
        diameter = getattr(operation, 'diameter', 10)
        pitch = getattr(operation, 'pitch', 1.5)
        depth = getattr(operation, 'depth', 15)
        
        lines.append(f"(Thread: M{int(diameter)} x {pitch})")
        lines.append("(Helical interpolation)")
        
        # Simplified - would need proper helical interpolation
        lines.append(f"G0 X{diameter/2:.{self.settings.precision}f} Y0")
        lines.append(f"G0 Z{self.settings.rapid_z:.{self.settings.precision}f}")
        lines.append(f"G1 Z-{depth:.{self.settings.precision}f} F{operation.feed_rate:.0f}")
        lines.append(f"G2 I-{diameter/2:.{self.settings.precision}f} J0 Z-{depth:.{self.settings.precision}f}")
        lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        lines.append("")
        
        return lines
    
    def _generate_contouring(self, operation) -> List[str]:
        """Generate contouring"""
        lines = []
        lines.append(f"({operation.operation_name})")
        lines.append("(Contour operation)")
        lines.append("")
        return lines
    
    def _generate_generic_milling(self, operation) -> List[str]:
        """Generate generic milling operation"""
        lines = []
        lines.append(f"({operation.operation_name})")
        lines.append(f"F{operation.feed_rate:.0f}")
        lines.append("")
        return lines
    
    def _generate_footer(self) -> List[str]:
        """Generate program footer"""
        lines = []
        lines.append("(PROGRAM END)")
        lines.append("M5 (Spindle stop)")
        lines.append("M9 (Coolant off)")
        lines.append(f"G0 Z{self.settings.safe_z:.{self.settings.precision}f}")
        lines.append("G28 Z0 (Return Z to home)")
        lines.append("M30 (Program end)")
        lines.append("%")
        return lines
    
    def _group_by_tool(self, operations: List) -> Dict[str, List]:
        """Group operations by tool"""
        groups = {}
        for op in operations:
            tool_id = f"{op.tool_type.value if hasattr(op.tool_type, 'value') else op.tool_type}-{op.tool_diameter}mm"
            if tool_id not in groups:
                groups[tool_id] = []
            groups[tool_id].append(op)
        return groups
    
    def _extract_tool_number(self, tool_id: str) -> int:
        """Extract tool number from tool ID"""
        # Simple hash-based numbering
        return hash(tool_id) % 99 + 1
    
    def _get_timestamp(self) -> str:
        """Get current timestamp"""
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")


def generate_gcode_from_fbm(operations: List, output_file: str = None, 
                            settings: GCodeSettings = None) -> str:
    """Convenience function to generate G-code from FBM operations"""
    generator = GCodeGenerator(settings)
    gcode = generator.generate_program(operations)
    
    if output_file:
        with open(output_file, 'w') as f:
            f.write(gcode)
    
    return gcode


# Example usage
if __name__ == "__main__":
    from dataclasses import dataclass
    
    # Mock operation for testing
    @dataclass
    class MockOp:
        operation_name: str
        tool_type: str
        tool_diameter: float
        spindle_speed: float
        feed_rate: float
        depth: float = 10.0
    
    ops = [
        MockOp("Drill Hole 1", "DRILL", 8.0, 3000, 300, 15),
        MockOp("Drill Hole 2", "DRILL", 8.0, 3000, 300, 15),
        MockOp("Pocket 1", "END_MILL", 10.0, 5000, 800, 10),
    ]
    
    gcode = generate_gcode_from_fbm(ops)
    print(gcode)
